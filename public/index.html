<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#001f3f" />
<title>Camera - CYNOOPS</title>
<link rel="manifest" href="/manifest.json" />
<link rel="icon" type="image/svg+xml" href="/icons/icon-192.svg" />
<link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="app">
    <header class="app-header">
      <div class="title-stack">
        <h1>Camera - CYNOOPS</h1>
        <p class="subtitle">Motion clip capture prototype</p>
      </div>
    </header>

    <main class="app-main">
      <section class="camera-view">
        <div class="video-shell">
          <video id="preview" playsinline muted autoplay></video>
          <div class="hud">
            <div class="hud-top">
              <div class="badge-row">
                <span class="badge" id="mimeBadge">—</span>
                <span class="badge" id="motionBadge">motion: 0</span>
                <span class="badge" id="bufferBadge">recording: idle</span>
              </div>
              <span class="badge badge-live" id="recBadge" style="visibility:hidden">● recording</span>
            </div>
            <div class="hud-bottom">
              <div class="meter"><div id="motionBar"></div></div>
            </div>
          </div>
        </div>
      </section>

      <aside class="event-panel">
        <div class="panel-card">
          <h2>Event Log</h2>
          <div class="log" id="log"></div>
        </div>
      </aside>
    </main>

    <footer class="app-actions">
      <div class="control-panel">
        <button id="startBtn">Start Camera</button>
        <button id="saveBtn" class="secondary" disabled>Save Clip</button>
        <button id="toggleMotionBtn" class="secondary">Motion: ON</button>
      </div>
      <small class="hint">
        Tip: this keeps a rolling 5s buffer. On detected motion it will auto-save 5s before and up to 60s after the last motion frame.
      </small>
    </footer>
  </div>

<script>
(async function(){
  const videoEl = document.getElementById('preview');
  const startBtn = document.getElementById('startBtn');
  const saveBtn = document.getElementById('saveBtn');
  const toggleMotionBtn = document.getElementById('toggleMotionBtn');
  const logEl = document.getElementById('log');
  const recBadge = document.getElementById('recBadge');
  const motionBadge = document.getElementById('motionBadge');
  const bufferBadge = document.getElementById('bufferBadge');
  const motionBar = document.getElementById('motionBar');
  const mimeBadge = document.getElementById('mimeBadge');

  // Tunables
  const TIMESLICE_MS = 300;               // chunk size from MediaRecorder
  const DATA_REQUEST_INTERVAL_MS = 900;   // force chunk delivery for browsers ignoring timeslice
  const MOTION_SAMPLE_MS = 160;           // how often we sample frames
  const PIXEL_DIFF_THRESHOLD = 26;        // per-channel diff threshold [0..255]
  const MOTION_START_THRESHOLD = 0.10;    // begin recording once ≥10% of sampled pixels change
  const MOTION_STOP_THRESHOLD = 0.03;     // consider motion low when ≤3% of pixels change
  const MOTION_STOP_DELAY_MS = 15_000;    // require low motion for 15s before stopping

  let stream = null;
  let recorder = null;
  let recMime = null;
  let initSegment = null; // first chunk with codec configuration
  let wakeLock = null;

  // rolling buffer of recorded blobs while motion is active
  const chunkBuffer = [];
  let bufferDurationMs = 0;

  // motion detection state
  let motionDetectionEnabled = true;
  let lastFrameData = null;
  let recordingActive = false;
  let lowMotionStartTs = 0;
  let clipStartTs = 0;

  const pendingDataResolvers = [];
  let recorderPump = null;

  function log(msg){
    const line = document.createElement('div');
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.prepend(line);
  }

  function resolvePendingDataResolvers() {
    while (pendingDataResolvers.length) {
      const resolve = pendingDataResolvers.shift();
      resolve();
    }
  }

  function bestMime() {
    const candidates = [
      'video/mp4;codecs=h264,aac',      // Safari/iOS (modern)
      'video/mp4;codecs=avc1.42E01E,mp4a.40.2', // alt h264+aac
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm;codecs=vp8',
      'video/webm',
    ];
    for (const m of candidates) {
      if ('MediaRecorder' in window && MediaRecorder.isTypeSupported(m)) return m;
    }
    return ''; // let browser pick default
  }

  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => log('WakeLock released.'));
        log('Screen WakeLock acquired.');
      }
    } catch(e) { log('WakeLock not available: ' + e.message); }
  }

  function updateBufferStats() {
    const chunkDurationMs = chunkBuffer.length * TIMESLICE_MS;
    if (recordingActive && clipStartTs) {
      bufferDurationMs = Math.max(chunkDurationMs, Date.now() - clipStartTs);
    } else {
      bufferDurationMs = chunkDurationMs;
    }
    if (recordingActive) {
      bufferBadge.textContent = `recording: ${(bufferDurationMs / 1000).toFixed(1)}s`;
      if (chunkBuffer.length > 0) {
        const secondsLabel = (chunkDurationMs / 1000).toFixed(1).replace(/\.0$/, '');
        saveBtn.textContent = `Save ${secondsLabel}s Clip`;
      } else {
        saveBtn.textContent = 'Save Clip';
      }
    } else {
      bufferBadge.textContent = 'recording: idle';
      saveBtn.textContent = 'Save Clip';
    }
    saveBtn.disabled = !recordingActive || chunkBuffer.length === 0;
  }

  function beginMotionRecording() {
    if (recordingActive) return;
    recordingActive = true;
    lowMotionStartTs = 0;
    clipStartTs = Date.now();
    chunkBuffer.length = 0;
    bufferDurationMs = 0;
    updateBufferStats();
    recBadge.style.visibility = 'visible';
    if (!startRecording()) {
      recordingActive = false;
      recBadge.style.visibility = 'hidden';
      updateBufferStats();
      return;
    }
    log('Motion recording started.');
  }

  function endMotionRecording(message = 'Motion recording stopped.') {
    if (!recordingActive) return;
    recordingActive = false;
    lowMotionStartTs = 0;
    clipStartTs = 0;
    chunkBuffer.length = 0;
    bufferDurationMs = 0;
    updateBufferStats();
    recBadge.style.visibility = 'hidden';
    if (recorder && recorder.state === 'recording') {
      try {
        recorder.stop();
      } catch (e) {
        log('Failed to stop recorder: ' + e.message);
      }
    }
    if (recorderPump) {
      clearInterval(recorderPump);
      recorderPump = null;
    }
    resolvePendingDataResolvers();
    log(message);
  }

  function downloadBlob(blob, prefix='clip') {
    const ext = recMime?.includes('mp4') ? 'mp4' : 'webm';
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${prefix}-${new Date().toISOString().replace(/[:.]/g,'-')}.${ext}`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function collectClip() {
    if (chunkBuffer.length === 0) return null;
    const parts = [];
    if (initSegment) parts.push(initSegment);
    parts.push(...chunkBuffer);
    return new Blob(parts, { type: recMime || 'video/webm' });
  }

  async function flushRecorderData() {
    if (!recorder || recorder.state !== 'recording') return;
    let resolverRef;
    const waitForChunk = new Promise((resolve) => {
      resolverRef = () => resolve('chunk');
      pendingDataResolvers.push(resolverRef);
    });
    try {
      recorder.requestData();
    } catch (e) {
      resolvePendingDataResolvers();
      return;
    }
    const result = await Promise.race([
      waitForChunk,
      new Promise((resolve) => setTimeout(() => resolve('timeout'), TIMESLICE_MS + 150))
    ]);
    if (result === 'timeout' && resolverRef) {
      const idx = pendingDataResolvers.indexOf(resolverRef);
      if (idx !== -1) pendingDataResolvers.splice(idx, 1);
    }
  }

  function startRecording() {
    if (!('MediaRecorder' in window)) {
      log('MediaRecorder not supported in this browser.');
      alert('MediaRecorder not supported here.');
      return false;
    }
    if (!stream) {
      log('No media stream available.');
      return false;
    }

    initSegment = null;

    try {
      recorder = new MediaRecorder(stream, recMime ? { mimeType: recMime, bitsPerSecond: 2_000_000 } : { bitsPerSecond: 2_000_000 });
    } catch (e) {
      log('Failed to create MediaRecorder: ' + e.message);
      try {
        recorder = new MediaRecorder(stream);
      } catch (err) {
        log('Unable to create MediaRecorder: ' + err.message);
        recorder = null;
        return false;
      }
    }

    const currentRecorder = recorder;
    mimeBadge.textContent = recMime ? recMime : (currentRecorder.mimeType || 'default');

    currentRecorder.ondataavailable = (ev) => {
      if (!ev.data || ev.data.size === 0) return;
      if (!initSegment) initSegment = ev.data;
      if (!recordingActive) {
        if (chunkBuffer.length > 0) {
          chunkBuffer.length = 0;
          bufferDurationMs = 0;
          updateBufferStats();
        }
        return;
      }
      chunkBuffer.push(ev.data);
      updateBufferStats();
      resolvePendingDataResolvers();
    };

    currentRecorder.onstop = () => {
      if (recorder === currentRecorder) {
        recorder = null;
      }
      if (recorderPump) {
        clearInterval(recorderPump);
        recorderPump = null;
      }
      log('Recorder stopped.');
    };

    currentRecorder.start(TIMESLICE_MS);
    if (recorderPump) clearInterval(recorderPump);
    recorderPump = setInterval(() => {
      if (recorder === currentRecorder && currentRecorder.state === 'recording') {
        try {
          currentRecorder.requestData();
        } catch (e) {
          // ignore, recorder might be stopping
        }
      }
    }, DATA_REQUEST_INTERVAL_MS);
    log('Recorder started.');
    return true;
  }

  function startMotionLoop() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    let lastSampleTs = 0;
    function sample() {
      requestAnimationFrame(sample);
      if (!motionDetectionEnabled) return;
      const now = performance.now();
      if (now - lastSampleTs < MOTION_SAMPLE_MS) return;
      lastSampleTs = now;

      const v = videoEl;
      if (v.videoWidth === 0 || v.videoHeight === 0) return;

      // Downscale for speed
      const scale = 0.25;
      canvas.width = Math.max(64, Math.floor(v.videoWidth * scale));
      canvas.height = Math.max(64, Math.floor(v.videoHeight * scale));
      ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
      const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);

      if (!lastFrameData) {
        lastFrameData = frame;
        return;
      }

      // Compare frames
      const a = frame.data, b = lastFrameData.data;
      const len = a.length;
      let changed = 0;
      for (let i = 0; i < len; i += 4) {
        const dr = Math.abs(a[i]   - b[i]);
        const dg = Math.abs(a[i+1] - b[i+1]);
        const db = Math.abs(a[i+2] - b[i+2]);
        // ignore alpha
        if (dr > PIXEL_DIFF_THRESHOLD || dg > PIXEL_DIFF_THRESHOLD || db > PIXEL_DIFF_THRESHOLD) {
          changed++;
        }
      }
      lastFrameData = frame;

      const totalPx = (len/4);
      const ratio = changed / totalPx;
      motionBadge.textContent = `motion: ${(ratio*100).toFixed(2)}%`;
      motionBar.style.width = Math.min(100, ratio * 100) + '%';

      if (ratio >= MOTION_START_THRESHOLD && !recordingActive) {
        beginMotionRecording();
      }

      if (recordingActive) {
        if (ratio <= MOTION_STOP_THRESHOLD) {
          if (!lowMotionStartTs) {
            lowMotionStartTs = Date.now();
          } else if (Date.now() - lowMotionStartTs >= MOTION_STOP_DELAY_MS) {
            endMotionRecording('Motion recording stopped (low activity).');
          }
        } else {
          lowMotionStartTs = 0;
        }
      } else {
        lowMotionStartTs = 0;
      }
    }
    sample();
  }

  async function startCamera() {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: true
      });
    } catch (e) {
      alert('Failed to start camera/mic: ' + e.message);
      throw e;
    }
    videoEl.srcObject = stream;

    await requestWakeLock();
    recMime = bestMime();
    mimeBadge.textContent = recMime ? recMime : 'default';
    startMotionLoop();
    updateBufferStats();

    startBtn.disabled = true;
  }

  startBtn.addEventListener('click', startCamera);

  saveBtn.addEventListener('click', async () => {
    if (!recordingActive) {
      log('No active motion recording to save.');
      return;
    }
    await flushRecorderData();
    const blob = collectClip();
    if (!blob || blob.size === 0) {
      log('Nothing to save yet.');
      return;
    }
    downloadBlob(blob, 'motion');
    log('Motion recording saved.');
  });

  toggleMotionBtn.addEventListener('click', () => {
    motionDetectionEnabled = !motionDetectionEnabled;
    toggleMotionBtn.textContent = `Motion: ${motionDetectionEnabled ? 'ON' : 'OFF'}`;
    if (!motionDetectionEnabled) {
      lowMotionStartTs = 0;
      endMotionRecording('Motion detection disabled.');
    }
    log(`Motion detection ${motionDetectionEnabled ? 'enabled' : 'disabled'}.`);
  });

  // Cleanup on page hide
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && wakeLock) {
      wakeLock.release().catch(()=>{});
      wakeLock = null;
    } else if (!document.hidden && !wakeLock) {
      requestWakeLock();
    }
  });

  window.addEventListener('beforeunload', () => {
    if (recorder && recorder.state !== 'inactive') recorder.stop();
    if (stream) stream.getTracks().forEach(t => t.stop());
  });

})();
</script>
</body>
</html>
